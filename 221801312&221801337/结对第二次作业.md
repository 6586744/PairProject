[toc]

| 这个作业属于哪个课程 | [2021春软工实践\|W班 (福州大学)](https://edu.cnblogs.com/campus/fzu/2021SpringSoftwareEngineeringPractice) |
| -------------------- | ------------------------------------------------------------ |
| 这个作业的要求在哪里 | [结对作业二](https://edu.cnblogs.com/campus/fzu/2021SpringSoftwareEngineeringPractice/homework/11890) |
| 结对学号             | 221801312、221801337                                         |
| 这个作业的目标       | 顶会热词统计的实现                                           |
| 其他参考文献         | 无                                                           |

## PSP表格

| Personal Software Process Stages | 预估耗时（分钟） | 实际耗时（分钟） |
| -------------------------------- | ---------------- | ---------------- |
| 计划                             |                  |                  |
| • 估计这个任务需要多少时间       | 5                | 10               |
| 开发                             |                  |                  |
| • 需求分析                       | 60               | 90               |
| • 学习使用原型设计工具           | 60               | 60               |
| • 原型具体设计                   | 600              | 720              |
| • 设计复审                       | 30               | 45               |
| 报告                             |                  |                  |
| • 设计报告                       | 60               | 90               |
| • 计算工作量                     | 20               | 20               |
| • 总结                           | 20               | 20               |
| **合计**                         | 855              | 1055             |

## Github仓库

### 仓库地址

- github地址：[yrc123/PairProject](https://github.com/yrc123/PairProject)
- 代码规范地址：

### 目录结构

```
.
├── 221801312&221801337
│   └── Java
│       ├── 后端				 (后端程序)
│       └── 数据处理		(处理json数据并导入到数据库的程序)
└── README.md
```

## 访问地址

- 部署访问地址：
- 后端接口展示地址：[swagger-ui](http://106.15.74.153:8080/swagger-ui/index.html?configUrl=/v3/api-docs/swagger-config)

## 作品展示

![image-20210329112054664](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210329112054664.png)

<center>接口展示页（使用swagger生成）</center>

## 结对讨论过程

![QQ图片2021033022204213](https://gitee.com/lin_haoran/Picgo/raw/master/img/QQ图片2021033022204213.png)

## 设计实现过程

### 数据导入程序

#### 结构图

![image-20210330133157357](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210330133157357.png)

#### 代码说明

- 使用FastJson来转换json文件
- 使用mybatis来把数据存入数据库

**PaperDao**

- Dao层，有保存查询数据库的方法

**PaperHandler**

- 因为给出的paper数据格式有两种，所以我定义了一个PaperHandler接口
- 这个接口要求实现一个将`JSONObject`转换成`Paper`类的`toPaper`方法
- 这样可以更好的复用其他的方法，把不同数据格式的差异给隐藏起来

**Paper**

- 论文类型的实体类
- 其中提供了两个方法，可以返回两种实现了`PaperHandler`接口的匿名类，分别对应两种不同格式的json文件

```java
public class Paper {
	...
	public static PaperHandler getDefultPaperHandler(){
        //函数式接口，返回一个匿名类，对应CVPR和ICCV会议的json格式
		return new PaperHandler() {
			@Override
			public Paper toPaper(JSONObject jo, String meetName, File file){
				Paper paper = new Paper();
                //使用FastJson解析数据，并放入Paper实体类中
				paper.setTitle(jo.getString("title"));
				paper.setAbstract(jo.getString("abstract"));
				if(paper.getAbstract()==null)paper.setAbstract("");
				List<String> authors=new ArrayList<>();
				final JSONArray ja = jo.getJSONArray("authors");
				for (int i = 0; i < ja.size(); i++) {
					authors.add(ja.getJSONObject(i).getString("name"));
				}
				paper.setAuthors(authors);
				if(jo.getJSONArray("keywords")!=null)
					paper.setKeywords(
							jo.getJSONArray("keywords")
									.getJSONObject(0).getJSONArray("kwd").toJavaList(String.class)
					);
				else
					paper.setKeywords(new ArrayList<>());
				paper.setMeet(meetName);
				final SimpleDateFormat year = new SimpleDateFormat("yyyy");
				Date date = null;
				try {
					date = year.parse(jo.getString("publicationYear"));
				} catch (ParseException e) {
					e.printStackTrace();
				}
				paper.setPublicationYear(date);
				paper.setUrl(jo.getString("pdfUrl"));
				return paper;
			}
		};
	}
    //同上，对应ECCV会议的json格式，这里不再赘述
	public static PaperHandler getECCVPaperHandler(){
        ...
	}
}
```

**Core**

- 需要会议的文件夹路径（path）、会议名（meetName）和会议对应的PaperHandler实现类来构造。
- 在PapersearchApplicaiton中分别注入三个Core，之后分别执行Core的start()方法来导入json文件到数据库

```json
@SpringBootApplication()
public class PapersearchApplication {
	...
	//注入三个Core对象
	@Bean(name = "iccv")
	public Core getIccv(){
		return new Core("./论文数据/ICCV", "ICCV", Paper.getDefultPaperHandler());
	}
	@Bean(name = "cvpr")
	public Core getCvpr(){
		return new Core("./论文数据/CVPR", "CVPR", Paper.getDefultPaperHandler());
	}
	@Bean(name = "eccv")
	public Core getEccv(){
		return new Core("./论文数据/ECCV", "ECCV", Paper.getECCVPaperHandler());
	}
	...
}
```

### 前端设计

### 后端设计

#### 技术栈

- 项目使用了spring boot为项目框架
- dao层用了mybatis
- 使用redis来缓存历史查询和图表数据，其中查询缓存时间为5分钟，图标信息缓存时间为1天
- 使用swagger来生成接口文档，方便前端调试

#### 结构图

- Spring Bean关系依赖图

![image-20210329202044483](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210329202044483.png)

![image-20210329202116538](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210329202116538.png)

#### 数据库设计

![image-20210329113814358](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210329113814358.png)

<center>数据库er图</center>

#### 代码说明

##### 使用Redis来缓存数据

**问题描述**

​	由于类似旭日图、柱状图的图表展示需要的数据查询量大，需要的查询时间较长，但是同时图表展示对数据的时效性要求并不高，所以应该使用缓存来提升查询速度、降低对数据库的压力。

**RedisConfigure类**

```java
/**
 *	通过注入自定义的CacheManager类来配置缓存
 */
@Configuration
public class RedisConfigure  {
    @Autowired
    private RedisConnectionFactory connectionFactory;
    @Bean(name="cacheManger")
    public CacheManager initRedisCacheManager(){
        HashMap<String ,RedisCacheConfiguration> configMap = new HashMap<>();
		//为不同的数据设置不同的ttl，在性能和数据时效性之间保持一个平衡
        configMap.put("similarWord",getMyConfigure().entryTtl(Duration.ofMinutes(3)));
        configMap.put("searchPaper",getMyConfigure().entryTtl(Duration.ofMinutes(5)));
        configMap.put("top10",getMyConfigure().entryTtl(Duration.ofDays(1)));
        configMap.put("sunburst",getMyConfigure().entryTtl(Duration.ofDays(1)));
		//用构造器构造CacheManager
        RedisCacheManager redisCacheManager = RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(getMyConfigure())
                .withInitialCacheConfigurations(configMap)
                .build();
        return redisCacheManager;
    }
    //返回一个自定义的默认配置
    private RedisCacheConfiguration getMyConfigure(){
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();
        //将存入redis缓存时使用的序列化器改为支持json的序列化器，提升缓存数据的可读性
        config=config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(RedisSerializer.json()));
        config=config.entryTtl(Duration.ofMinutes(5));
        return config;
    }
}

```

**关于自调用缓存失效**

​	由于spring boot的缓存注解是通过AOP织入的，所以在类内的自调用不是调用代理对象，如：

```java
public class MyService{
    @Cacheable
    	public Map<String,Object> searchPaperCount(...){...}
	@Cacheable
    	public Map<String,Object> searchPaper(...){
            ...
            res.put(this.searchPaperCount(...));//自调用，缓存失效
            ...
        }
}
```

​	解决方法则是在类内注入当前类的接口或者直接注入当前类，然后调用注入的对象即可。

```java
public class MyService{
    @Autowired
    MyService service;
        @Cacheable
    	public Map<String,Object> searchPaperCount(...){...}
	@Cacheable
    	public Map<String,Object> searchPaper(...){
            ...
            res.put(service.searchPaperCount(...));//调用了代理类，缓存生效
            ...
        }
}
```

**结果**

![image-20210330003638824](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210330003638824.png)

<center>第一次查询</center>

![image-20210330003656082](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210330003656082.png)

<center>第二次查询</center>

![image-20210330161315760](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210330161315760.png)

<center>redis中缓存的数据</center>

​	这里测试了sunburst接口，虽然这个接口的查询量大但是对数据的时效性要求不高，所有可以使用缓存。由上面的两次查询可以看到，由于第二次查询是从redis读取缓存，相比于从数据库查询，查询时间从477ms下降到了83ms，时间只有原来的$\frac{1}{5}$，极大提升了用户体验。

##### 使用Aspect来包装数据

**问题描述**

​	请求和响应的数据都有统一的格式，下面是一个响应的数据格式

```json
{
    timestamp:"当前时间戳",
    staus:"状态码",
    data:"实际返回的数据",
    message:"消息",
    path:"请求的URI"
}
```

​	如果在每个Controller中都对数据的格式进行解析和封装，会造成代码的冗余，并且不便于后续维护。所以使用Aop来处理数据格式

**ControllerAspect类**

```java
@Component
@Aspect
public class ControllerAspect {
    //设置切点
    @Pointcut("execution( * com.jdzy.papersearch.controller.*.*(..))")
    public void pointCut(){}

    //定义切面
    @Around("pointCut()")
    public Map<String,Object> getData(ProceedingJoinPoint jp){
		//获取被代理函数的传入参数
        Object[] args = jp.getArgs();
        HttpServletRequest httpReq = (HttpServletRequest) args[args.length-1];
        if(args[0]!=null&&args[0].getClass().getInterfaces()[0]==Map.class){
            Map<String,Object> data = (Map<String, Object>) args[0];
            data= (Map<String, Object>) data.get("data");
            args[0]=data;
        }
        Object resp = null;
        try {
            //执行连接点，并获取返回值
            resp = jp.proceed(args);
        } catch (Throwable throwable) {
            log.error("Around失败");
            throwable.printStackTrace();
        }
		//通过自己实现的HttpTools来包装返回值
        return HttpTools.buildSuccessResp(resp, httpReq.getRequestURI());
    }
}
```

**结果**

- 织入前返回的数据

![image-20210330112038819](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210330112038819.png)

- 织入后返回的数据

![image-20210330112154003](https://gitee.com/lin_haoran/Picgo/raw/master/img/image-20210330112154003.png)

##### 关键词补全和文章搜索的接口实现

**关键代码**

- `PaperSearchService`

```java
@Service
public class PaperSearchService {
    //各种dao层注入
	@Autowired
	KeywordDao kDao;
	@Autowired
	PaperDao pDao;
	@Autowired
	AuthorDao aDao;
	@Autowired
	PaperSearchService service;

   /**
	 * 关键词补全接口 
	 * @param word：用户已输入的关键词
	 * @param limit：限制返回的条数
	 */
	@Cacheable(value = "similarWord",
			key="'word_'+#word+'_'+#limit")
	public List<Keyword> searchSimilarWord(String word,Integer limit){
		//通过' '和'+'来分割输入的关键词
		String[] split = word.split(" |\\+");
        //通过LinkedHashSet来保证在去重的同时保证插入的优先级
		HashSet<Keyword> set = new LinkedHashSet<>();
        //优先搜索分割之前的关键字，以求最大匹配
		List<Keyword> similarKeyword = kDao.findSimilarKeyword(word,limit);
		set.addAll(kDao.findSimilarKeyword(word,limit));
        //循环查找分割后的单词，直到超出返回条数的限制
		for (String s : split) {
			if(set.size()>=limit){
				break;
			}
			set.addAll(kDao.findSimilarKeyword(s,limit));
		}
		List<Keyword> strings = new ArrayList<>(set);
		limit=Math.min(limit,strings.size());
        //由于subString无法序列化，所以构造一个新List来返回
		ArrayList<Keyword> res = new ArrayList<>(strings.subList(0, limit));
		return res;
	}
    
    /**
	 * 文章搜索接口，可同时查询标题和作者
	 * @param searchWord 关键词
	 * @param orderBy 排序方式，最相关或最新发布
	 * @param time 近n年文章
	 * @param meetId 会议id
	 * @param limit 返回条数限制
	 * @param page 分页时当前的页数
	 */
	@Cacheable(value = "searchPaper",
			key="'paper_'+#searchWord+'_'+#orderBy+'_'+#time+'_'+#meetId+'_'+#page")
	public Map<String,Object> searchPaper(String searchWord,Integer orderBy,Integer time,Integer meetId,Integer limit,Integer page){
		Map<String, Object> resp = new HashMap<>();
		List<Map<String,Object>> paperList= new ArrayList<>();
		Date years = null;
        //通过传入的time来生成查询的时间条件
		if(time!=null){
			int year = Calendar.getInstance().get(Calendar.YEAR);
			year-=time;
			try {
				years = new SimpleDateFormat("yyyy").parse(String.valueOf(year));
			} catch (ParseException e) {
				e.printStackTrace();
			}
		}
        //如果页数和限制条数不为空，就处理
		Integer pages=null;
		if(limit!=null&&page!=null){
			pages=limit*page;
		}
        //传入dao查询
		List<Paper> papers = pDao.findPaperByWord(searchWord, orderBy, years, meetId, limit, pages);
		for (Paper paper : papers) {
			Map<String, Object> node = new HashMap<>();
            //通过文章id查对应的所有作者
			List<Author> authors = new ArrayList<>(aDao.findAuthorByPaperId(paper.getId(),15));
            //通过文章id查对应的关键词
			List<Keyword> keywords = new ArrayList<>(kDao.findKeywordByPaperId(paper.getId(),null));
            //封装数据
			...
		}
		resp.put("paperList",paperList);
        //获取当前查询结果的总条数
		resp.put("count",service.searchPaperCount(searchWord,years,meetId));
		return resp;
	}
    /**
     * 用来统计当前搜索条件的总数据条数，方便前端分页
     * 同样使用redis缓存，保证对应关键字的第一次请求会查询数据库
     */
	@Cacheable(value = "searchPaper",
			key="'paper_'+#searchWord+'_'+#publicationYears+'_'+#meetId")
	public Integer searchPaperCount(String searchWord,Date publicationYears,Integer meetId){
		return pDao.findPaperCountByWord(searchWord,publicationYears,meetId);
	}
}
```

<center><a href="http://106.15.74.153:8080/swagger-ui/index.html?configUrl=/v3/api-docs/swagger-config#/%E6%90%9C%E7%B4%A2api/searchWord">测试接口</a></center>

- mybatis配置文件`PaperMapper.xml`

```xml
...
<mapper namespace="com.jdzy.papersearch.dao.PaperDao">
    ...
    <!--searchPaper中调用的寻找文章的sql语句-->
	<select id="findPaperByWord" resultType="com.jdzy.papersearch.pojo.Paper">
		select * from paper
		where title like concat("%",concat(#{searchWord},"%"))
		or paper.id in (<!--作者的子查询-->
		    select paper_id
		    from author,paper_author
		    where author.name like concat("%",concat(#{searchWord},"%"))
		    and author.id=paper_author.author_id
		)
		<if test="publicationYears!=null">
			and publication_year>=#{publicationYears}
		</if>
		<if test="meetId!=null">
			and meet_id=#{meetId}
		</if>
		<if test="orderBy==1">
			order by publication_year desc
		</if>
		<if test="page!=null and limit!=null">
			limit #{page},#{limit}
		</if>
	</select>
	...
</mapper>
```

### 部署方式

- 前端通过nodejs打包成。。。
- 后端通过maven打包成jar后直接在服务器上运行
- 通过nginx反向代理来解决跨域问题并启用负载均衡

**nginx配置文件**

![C799](https://gitee.com/lin_haoran/Picgo/raw/master/img/C799.png)

- redis部署方式为主从模式，提升读写性能

**master服务器**

![2021-03-30_12-05](https://gitee.com/lin_haoran/Picgo/raw/master/img/2021-03-30_12-05.jpg)

**slave服务器**

![2021-03-30_12-07](https://gitee.com/lin_haoran/Picgo/raw/master/img/2021-03-30_12-07.jpg)

## 心路历程及收获

- 221801312

> 

- 221801337

> 这次作业是第一次把我寒假学习的知识运用到实战中。但是因为寒假学习中，我都是有照着书一步步实现的，所以这次基本上没有遇到什么问题。这次的收获就是对零散的知识的一次整合运用。

## 评价结对队友

- 221801312

> 

- 221801337

> 